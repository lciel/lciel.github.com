<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Unmotivated]]></title>
  <link href="http://blog.lciel.jp/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.lciel.jp/"/>
  <updated>2013-11-30T22:19:29+09:00</updated>
  <id>http://blog.lciel.jp/</id>
  <author>
    <name><![CDATA[lciel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ViewGroup では onDraw() の代わりに dispatchDraw() が呼ばれる]]></title>
    <link href="http://blog.lciel.jp/blog/2013/11/27/viewgroup-dispatchdraw/"/>
    <updated>2013-11-27T20:18:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/11/27/viewgroup-dispatchdraw</id>
    <content type="html"><![CDATA[<p>FrameLayout で onDraw() のタイミングで処理をしたいが、 onDraw() が呼ばれなかった。</p>

<p>表題の通り、 ViewGroup を継承したクラスは onDraw() の代わり dispatchDraw() が呼ばれる。<br/>
(その名の通り子の View に対して draw() をコールしたりしなかったりするメソッド)</p>

<p>ViewGroup を継承したクラスに対して onDraw() のタイミングで実行したい処理は、 dispatchDraw() に書けば問題なさそう。
``` java
@Override
protected void dispatchDraw(Canvas canvas) {</p>

<pre><code>/*
    canvas に対して処理をしたりなんだり...
*/
super.dispatchDraw(canvas);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 4.3 で ImageView#getImageMatrix() の挙動が変わっている]]></title>
    <link href="http://blog.lciel.jp/blog/2013/11/25/imageview-getimagematrix/"/>
    <updated>2013-11-25T11:19:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/11/25/imageview-getimagematrix</id>
    <content type="html"><![CDATA[<p>今まで ImageView#getImageMatrix() で取得した Matrix のインスタンスに対して、直接 post*() のメソッドを呼んだりして操作すれば表示に反映されていたが、どうやら 4.3 で挙動が変わったご様子。</p>

<p>結論から言うと、横着せずにちゃんと毎回 setImageMatrix() をしてやるか、はじめに setImageMatrix() してから getImageMatrix() を使うようにすれば想定通りに動作する。
``` java
ImageView imageView = findViewById(R.id.imageView);</p>

<p>float ratio = 2.0f;
Matrix matrix = imageView.getImageMatrix();
matrix.postScale(ratio, ratio);</p>

<p>matrix.setImageMatrix(matrix);
<code>
</code> java
ImageView imageView = findViewById(R.id.imageView);</p>

<p>Matrix matrix = new Matrix();
imageView.setImageMatrix();</p>

<p>float ratio = 2.0f;
matrix = imageView.getImageMatrix();
matrix.postScale(ratio, ratio);
```</p>

<h3>どう変わってるのか確認</h3>

<p>4.2 以前では mMatrix (initImageView()で初期化されてる)がそのまま返っているのに対して、 4.3 以降では mDrawMatrix が返るようになっている。
(mDrawMatrix は configureBounds() でセットされている)</p>

<p>mDrawMatrix がセットされていない状態だと、その場で Matrix のインスタンスが作られているため、このインスタンスに対して直接操作を行っても反映されないというわけでした。</p>

<p>``` java 4.2_r1 android.widget.ImageView#getImageMatrix() <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29</a>
public Matrix getImageMatrix() {</p>

<pre><code>return mMatrix;
</code></pre>

<p>}
<code>
</code> java 4.3_r1 android.widget.ImageView#getImageMatrix() <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.3_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.3_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29</a>
public Matrix getImageMatrix() {</p>

<pre><code>if (mDrawMatrix == null) {
    return new Matrix(Matrix.IDENTITY_MATRIX);
}
return mDrawMatrix;
</code></pre>

<p>}
```</p>

<p>Android はマイナーバージョンアップでも、結構こういう細かい挙動変更が入ってくるので、以前動いていたものが突然動かなくなることが良くあるのだけれど、Android のコードを直接見に行けば答えが書いてあるので安心感がありますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ListView で onItemClick() と onItemLongClick() を両立]]></title>
    <link href="http://blog.lciel.jp/blog/2013/11/22/onitemclick-vs-onitemlongclick/"/>
    <updated>2013-11-22T18:50:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/11/22/onitemclick-vs-onitemlongclick</id>
    <content type="html"><![CDATA[<p>ListView で onItemClick() と onItemLongClick() を同時に仕掛けた際に、指を離すタイミングによっては onItemLongClick() に続けて onItemClick() が呼ばれてしまう。</p>

<p>一般的な Touch Event の例に漏れず、 onItemLongClick() で true を返しておけば、その後のイベントはキャンセルされる。
``` java
@Override
public void onItemClick(AdapterView&lt;?> parent, View view, int position, long id) {</p>

<pre><code>/*
    なんやかんや
*/
</code></pre>

<p>}</p>

<p>@Override
public boolean onItemLongClick(AdapterView&lt;?> parent, View view, int position, long id) {</p>

<pre><code>/*
    なんやかんや
*/
return true;    // これで onItemLongClick() のあとに onItemClick() が呼ばれなくなる
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewFlipper の InAnimation を1つ目には適用しない]]></title>
    <link href="http://blog.lciel.jp/blog/2013/11/21/disable-in-animation-of-viewflipper/"/>
    <updated>2013-11-21T20:58:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/11/21/disable-in-animation-of-viewflipper</id>
    <content type="html"><![CDATA[<p>ViewFlipper に InAnimation を設定した状態で startFlipping() をコールした際に、1つ目の View にも InAnimation が適用されてしまうのを回避したい。</p>

<p>AutoStart を指定せずに明示的に startFlipping() をコールした後に setInAnimation() してやれば OK
``` java
ViewFlipper viewFlipper = (ViewFlipper) findViewById(R.id.viewFlipper);</p>

<p>// viewFlipper.setAutoStart(true);
viewFlipper.startFlipping();
viewFlipper.setInAnimation(this, R.anim.fadein);
viewFlipper.setOutAnimation(this, R.anim.fadeout);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 端末のシェアを視覚的に見る]]></title>
    <link href="http://blog.lciel.jp/blog/2013/11/21/android-fragmentation-visualized/"/>
    <updated>2013-11-21T20:46:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/11/21/android-fragmentation-visualized</id>
    <content type="html"><![CDATA[<p>OpenSignal が公開してくれている、 Android 端末毎のシェアを視覚的に表示してくれるサービス。</p>

<ul>
<li><a href="http://opensignal.com/reports/fragmentation-2013/">Android Fragmentation Visualized</a></li>
</ul>


<p>こうみると SAMSUNG 一強だな。。</p>
]]></content>
  </entry>
  
</feed>
