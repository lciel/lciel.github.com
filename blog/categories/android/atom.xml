<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Unmotivated]]></title>
  <link href="http://blog.lciel.jp/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.lciel.jp/"/>
  <updated>2013-12-11T19:51:54+09:00</updated>
  <id>http://blog.lciel.jp/</id>
  <author>
    <name><![CDATA[lciel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android のアニメーションを自作する]]></title>
    <link href="http://blog.lciel.jp/blog/2013/12/11/android-custom-animation/"/>
    <updated>2013-12-11T20:15:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/12/11/android-custom-animation</id>
    <content type="html"><![CDATA[<p>Android で独自定義のカスタムアニメーションを作りたかったので試してみたところ、 Animation クラスを継承して割と簡単に作れたのでメモ。</p>

<p>ここでは例として、 View を円周に沿って動かすようなアニメーションを作ってみました。<br/>
アニメーションさせたい View に対して中心点を指定して、開始角度と終了角度を与えてアニメーションさせてみます。</p>

<p><img src="/images/android-arc-translate-animation.png" alt="円弧上を動かすアニメーション" /></p>

<p>``` java
/<em>*
 * 円弧上に沿うように移動させるアニメーション
 * @param startDegrees  開始角度
 * @param endDegrees    終了角度
 * @param centerXType   中心点のX座標のタイプ
 * @param centerXValue  中心点のX座標を表す値
 * @param centerYType   中心点のY座標のタイプ
 * @param centerYValue  中心点のY座標を表す値
 </em>/
public ArcTranslateAnimation(int startDegrees, int endDegrees,</p>

<pre><code>    int centerXType, float centerXValue, int centerYType, float centerYValue);
</code></pre>

<p>```</p>

<!-- more -->


<h3>コンストラクタ</h3>

<p>今回はパラメータを受け取るだけ。
``` java</p>

<pre><code>public ArcTranslateAnimation(int startDegrees, int endDegrees,
        int centerXType, float centerXValue, int centerYType, float centerYValue) {
    this.mStartRad = (float)(startDegrees * Math.PI / 180.0f);
    this.mEndRad   = (float)(endDegrees   * Math.PI / 180.0f);
    this.mCenterXType  = centerXType;
    this.mCenterXValue = centerXValue;
    this.mCenterYType  = centerYType;
    this.mCenterYValue = centerYValue;
}
</code></pre>

<p>```</p>

<h3>initialize()</h3>

<p>まず initialize() で View の座標やサイズなどの情報を取得します。</p>

<p>他のアニメーションに倣い、回転の中心点を指定するときに絶対的(Animation.ABSOLUTE)か相対的(Animation.RELATIVE_TO_SELF)か、親基準で相対的(Animation.RELATIVE_TO_PARENT)かを選べるようにしてみましたが、このあたりは resolveSize() メソッドを使うことで容易に座標に変換できます。</p>

<p>``` java</p>

<pre><code>@Override
public void initialize(int width, int height, int parentWidth,
        int parentHeight) {
    super.initialize(width, height, parentWidth, parentHeight);

    float fromX   = resolveSize(Animation.ABSOLUTE, 0, width, parentWidth);
    float fromY   = resolveSize(Animation.ABSOLUTE, 0, height, parentHeight);
    float centerX = resolveSize(mCenterXType, mCenterXValue, width, parentWidth);
    float centerY = resolveSize(mCenterYType, mCenterYValue, height, parentHeight);

    mDeltaRad = (float)Math.atan2(fromY - centerY, fromX - centerX);
    mRadius = (float)Math.sqrt(Math.pow(fromX - centerX, 2) + Math.pow(fromY - centerY, 2));
    mStartPoint = new Point((int)(fromX - centerX), (int)(fromY - centerY));
}
</code></pre>

<p>```</p>

<p>中心点の座標がとれたので、開始地点と中心点における初期角度、円の半径、開始点などを保存しておきます。</p>

<h3>applyTransformation()</h3>

<p>applyTransformation() がアニメーションのキモで、引数として渡される interpolatedTime パラメータに 0.0f &ndash; 1.0f でアニメーションの進行値が入ってくるので、その値に合わせて表示を変更してやります。
ちなみに interpolatedTime は Interpolator が適用された値が設定されているようなので、与えられた値をそのまま進行の割合として信じれば良さそうです。</p>

<p>表示を変更するには、同じく引数として渡される t パラメータに対して操作を行えば OK です。
位置やサイズを変更するなら getMatrix() で参照できる Matrix インスタンスを操作し、アルファ値を変更するなら setAlpha() でアルファ値を設定します。</p>

<p>``` java</p>

<pre><code>private PointF getArcPoint(float interpolatedTime) {
    float rad = mStartRad + (mEndRad - mStartRad) * interpolatedTime + mDeltaRad;
    float dx = (float)(Math.cos(rad) * mRadius);
    float dy = (float)(Math.sin(rad) * mRadius);
    return new PointF(dx - mStartPoint.x, dy - mStartPoint.y);
}

@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
    PointF p = getArcPoint(interpolatedTime);
    t.getMatrix().postTranslate(p.x, p.y);
}
</code></pre>

<p>```</p>

<p>今回は Translate アニメーションなので、 getArcPoint() で座標を決定したら Matrix#postTranslate() で位置を移動してやります。</p>

<h3>カスタムアニメーションを使用する</h3>

<p>これで普通の Animation と同じように使うことができます。</p>

<p>``` java 使用例
View target = findViewById(R.id.targetView);</p>

<p>Animation anim1 = new ArcTranslateAnimation(0, 90, Animation.ABSOLUTE, -300, Animation.ABSOLUTE, 0);
anim1.setDuration(1000);
anim1.setFillEnabled(true);
anim1.setFillAfter(true);
target.startAnimation(anim1);</p>

<p>Animation anim2 = new ArcTranslateAnimation(90, 0, Animation.ABSOLUTE, -300, Animation.ABSOLUTE, 0);
anim2.setStartOffset(1000);
anim2.setDuration(1000);
anim2.setFillEnabled(true);
anim2.setFillAfter(true);
target.startAnimation(anim2);
```</p>

<p>もちろん AnimationSet で使うこともできます。</p>

<p>最後に今回作成した ArcTranslateAnimation クラスを置いておきます。</p>

<p>``` java ArcTranslateAnimation.java
import android.graphics.Point;
import android.graphics.PointF;
import android.view.animation.Animation;
import android.view.animation.Transformation;</p>

<p>public class ArcTranslateAnimation extends Animation {</p>

<pre><code>private int mCenterXType;
private int mCenterYType;
private float mCenterXValue;
private float mCenterYValue;

private float mRadius;
private Point mStartPoint;

private float mDeltaRad;
private float mStartRad;
private float mEndRad;

/**
 * 円弧上に沿うように移動させるアニメーション
 * @param startDegrees  開始角度
 * @param endDegrees    終了角度
 * @param centerXType   中心点のX座標のタイプ
 * @param centerXValue  中心点のX座標を表す値
 * @param centerYType   中心点のY座標のタイプ
 * @param centerYValue  中心点のY座標を表す値
 */
public ArcTranslateAnimation(int startDegrees, int endDegrees,
        int centerXType, float centerXValue, int centerYType, float centerYValue) {
    this.mStartRad = (float)(startDegrees * Math.PI / 180.0f);
    this.mEndRad   = (float)(endDegrees   * Math.PI / 180.0f);
    this.mCenterXType  = centerXType;
    this.mCenterXValue = centerXValue;
    this.mCenterYType  = centerYType;
    this.mCenterYValue = centerYValue;
}

/**
 * 現在の座標を取得する
 * @param interpolatedTime
 * @return
 */
private PointF getArcPoint(float interpolatedTime) {
    float rad = mStartRad + (mEndRad - mStartRad) * interpolatedTime + mDeltaRad;
    float dx = (float)(Math.cos(rad) * mRadius);
    float dy = (float)(Math.sin(rad) * mRadius);
    return new PointF(dx - mStartPoint.x, dy - mStartPoint.y);
}

@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
    PointF p = getArcPoint(interpolatedTime);
    t.getMatrix().postTranslate(p.x, p.y);
}

@Override
public void initialize(int width, int height, int parentWidth,
        int parentHeight) {
    super.initialize(width, height, parentWidth, parentHeight);

    float fromX   = resolveSize(Animation.ABSOLUTE, 0, width, parentWidth);
    float fromY   = resolveSize(Animation.ABSOLUTE, 0, height, parentHeight);
    float centerX = resolveSize(mCenterXType, mCenterXValue, width, parentWidth);
    float centerY = resolveSize(mCenterYType, mCenterYValue, height, parentHeight);

    mDeltaRad = (float)Math.atan2(fromY - centerY, fromX - centerX);
    mRadius = (float)Math.sqrt(Math.pow(fromX - centerX, 2) + Math.pow(fromY - centerY, 2));
    mStartPoint = new Point((int)(fromX - centerX), (int)(fromY - centerY));
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ファイル名に特定の記号が使用できる場合とできない場合がある]]></title>
    <link href="http://blog.lciel.jp/blog/2013/12/06/android-sdcard-vfat/"/>
    <updated>2013-12-06T21:11:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/12/06/android-sdcard-vfat</id>
    <content type="html"><![CDATA[<p>Android のバージョンは同じなのに、端末によってファイルの移動(renameTo())に失敗してしまうことがあって悩まされたが、オチは移動先のファイル名にクエスチョンマーク(&ldquo;?&rdquo;)が含まれていたことが原因だった。</p>

<p>クエスチョンマークが入ってしまっていたこと自体がバグだったのだけれど、そもそも何で端末によってこのようなことが起きるのかを軽く追ってみた。</p>

<h3>原因はファイルシステム(っぽい)</h3>

<p>成功する端末では内部ストレージに書き込みを行っており、失敗する端末では外部ストレージに書き込みを行っていた。</p>

<p>ファイルシステムを見てみると、内部ストレージは FUSE でマウントされているのに対し、外部ストレージは VFAT でマウントされていた。</p>

<p>``` text mount の状態</p>

<h1>内部ストレージとして認識されているディレクトリ</h1>

<p>/dev/fuse /storage/sdcard0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</p>

<h1>外部ストレージとして認識されているディレクトリ</h1>

<p>/dev/block/vold/179:33 /storage/sdcard0/external_sd vfat rw,dirsync,nosuid,nodev,noexec,relatime,uid=1000,gid=1015,fmask=0602,dmask=0602,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0
```</p>

<p>正式な出典が見つからなかったけれど、 VFAT ではファイル名に以下の文字の使用を禁止しているようなので、恐らくこれが原因っぽい。<br/>
試しにその他の記号を含めたファイル名を作成してみたところ、全て失敗した。</p>

<p><code>text
\ : * ? &lt; &gt; | / ;
</code></p>

<p>参考 : <a href="http://www2s.biglobe.ne.jp/~system/doc/winfile2.htm">ファイル名とフォルダ名で使用できない文字</a></p>

<p>というわけで、環境によって(サンプル数は少ないが、恐らく外部SDカードでは)一部の記号がファイル名に使えなくなることがある、ということが分かった。</p>

<h3>メモ</h3>

<p>Android のファイルシステム周りについては全く調べられていないが、いくつか気になることがあったのでメモ。</p>

<ul>
<li>エミュレータでは FUSE ではなく YAFFS2 でマウントされていた(どこのレイヤーで変わってるのか不明)</li>
<li><a href="http://source.android.com/devices/tech/storage/">ここ</a>を見ると、 Android 4.4 からは外部ストレージも FUSE 経由でマウントするようになるっぽい？が、4.4 のエミュレータが起動せず、実機も外部メモリがマウントできない端末しかなく確認できず (raw storage をラップしているとあるので、今回の件は実体の方でこけそう)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ListView#setEmptyView() について]]></title>
    <link href="http://blog.lciel.jp/blog/2013/12/04/listview-setemptyview/"/>
    <updated>2013-12-04T21:10:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/12/04/listview-setemptyview</id>
    <content type="html"><![CDATA[<p>ListView の要素が無い場合に表示する View を指定できる setEmptyView() だが、その名前から想像できるのとは少し違う動きをする。</p>

<ul>
<li>違 : 「要素が無い場合に ListView の子供として表示させる View が設定できる」</li>
<li>正 : 「要素が無い場合に ListView の代わりに表示する View が設定できる」</li>
</ul>


<p>実際の動作は setEmptyView() で指定した View と ListView の Visibility を View.GONE と View.VISIBLE で入れ替えるだけとなっている。</p>

<p>そのため、 inflate() しただけでどこにも addView() していない View などを setEmptyView() で指定しても表示されないし、 ListView の子として表示される Header や Footer も表示されないこととなる。</p>

<p>通常は ListView と同階層に兄弟 View として xml に定義しておくのがよさそう。<br/>
EmptyView として設定する View の Visibility は特に指定しなくても ListView 側でやってくれるので問題ないです。
```xml
&lt;ListView</p>

<pre><code>android:id="@+id/listView"
... /&gt;
</code></pre>

<p>&lt;View</p>

<pre><code>android:id="@+id/emptyView"
... /&gt;
</code></pre>

<p><code>
</code>java
ListView listView = (ListView) findViewById(R.id.listView);
listView.setEmptyView(findViewById(R.id.emptyView));
```</p>

<p>以下は実装箇所の確認。
```java android.widget.AdapterView(1.6_r2)
private void More &hellip;updateEmptyStatus(boolean empty) {</p>

<pre><code>if (isInFilterMode()) {
    empty = false;
}

if (empty) {
    // EmptyView が設定されていた場合は自身を消して、 EmptyView を表示させている
    if (mEmptyView != null) {
        mEmptyView.setVisibility(View.VISIBLE);
        setVisibility(View.GONE);
    } else {
        // If the caller just removed our empty view, make sure the list view is visible
        setVisibility(View.VISIBLE);
    }
    // ...

} else {
    // ...
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android のタッチイベントを理解する(その1)]]></title>
    <link href="http://blog.lciel.jp/blog/2013/12/03/android-touch-event/"/>
    <updated>2013-12-03T20:31:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/12/03/android-touch-event</id>
    <content type="html"><![CDATA[<p>タッチイベントがうまく流れてこなくて困ったり、自力でイベントをルーティングしたりするときに困ったりと、ちょこちょことタッチイベントについて勉強したのでまとめておきます。<br/>
主にタッチイベントがどう流れてどう止まるかなどについて調べています。</p>

<p>イベントの流れを理解するには以下の資料がかなり参考になりました。</p>

<ul>
<li><a href="http://devsbuild.it/files/PRE_andevcon_mastering-the-android-touch-system.pdf">Mastering the Android Touch System (PDF)</a></li>
</ul>


<p>毎度のことながら、間違いがありましたらご指摘頂ければ幸いです。</p>

<!-- more -->


<h2>タッチイベントを処理する主要なメソッド</h2>

<p>実際の流れを理解する前に、主要なメソッドを三つ紹介しておきます。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> <strong>メソッド名</strong> </th>
<th align="left"> <strong>概要</strong> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> onTouchEvent() (<a href="http://developer.android.com/reference/android/view/View.html#onTouchEvent(android.view.MotionEvent">View</a>) </td>
<td align="left"> タッチイベントに対して何かを処理するメソッド。setOnTouchListener() で登録した listener はこのタイミングで呼び出される。</td>
</tr>
<tr>
<td></td>
<td align="left"> onInterceptTouchEvent() (<a href="http://developer.android.com/reference/android/view/ViewGroup.html#onInterceptTouchEvent(android.view.MotionEvent">ViewGroup</a>) </td>
<td align="left"> タッチイベントが子供へと伝搬することを阻止できるメソッド。</td>
</tr>
<tr>
<td></td>
<td align="left"> dispatchTouchEvent() (<a href="http://developer.android.com/reference/android/app/Activity.html#dispatchTouchEvent(android.view.MotionEvent">Activity</a>, <a href="http://developer.android.com/reference/android/view/View.html#dispatchTouchEvent(android.view.MotionEvent">View</a>, <a href="http://developer.android.com/reference/android/view/ViewGroup.html#dispatchTouchEvent(android.view.MotionEvent">ViewGroup</a>) </td>
<td align="left"> タッチイベントを受け取り、子に伝搬させるかどうか、自分が処理するかどうかなどを管理する。onInterceptTouchEvent() や onTouchEvent() を呼ぶ人。</td>
</tr>
</tbody>
</table>


<p>　</p>

<h2>基本的なタッチイベントの流れ</h2>

<p>タッチイベントは Activity を経由して PhoneWindow 直下の DecorView から伝搬が始まり、親の View からその子 View へと dispatchTouchEvent() なるメソッドを通じて伝搬していきます。</p>

<p>dispatchTouchEvent() は 自身が ViewGroup だった場合、まず自身の onInterceptTouchEvent() を呼び出します。
onInterceptTouchEvent() では子にイベントを渡すかどうかなどを判断します(後で詳しく説明します)。</p>

<p>次に、子の dispatchTouchEvent() を呼び出してイベントを渡していきます。
このとき、親が子の dispatchTouchEvent() を呼び出す順番は、一番新しく追加した子から古い子へと逆順に渡していきます。</p>

<p>そして、最後に一般的にタッチイベントを処理するメソッドである onTouchEvent() が dispatchTouchEvent() によって呼ばれます。
この onTouchEvent() は、子から親へと逆順(ユーザから見ると手前に表示されている順)に流れていくようになっています。</p>

<p>文章だけだと分かりづらいので、たとえば以下のような構成の View の場合を考えてみます。</p>

<p><img src="/images/android_touch_event_sample_view.png" alt="Sample View" />
<code>`` text
FrameLayout1(白)
|-- FrameLayout2(赤)
</code>&mdash; FrameLayout3(緑)</p>

<pre><code>`- Button
</code></pre>

<p>```</p>

<p>この構成の場合、いずれの View もタッチイベントを処理しない、最もシンプルなイベントの流れは以下のようになります。</p>

<p><img src="/images/android_touch_event_flow_01.png" alt="TouchEvent Flow" /></p>

<p>(1) から (13) の順番で処理が流れ、 onInterceptTouchEvent() が呼び出される順番は (I) から (III) となり、肝心の onTouchEvent() が呼び出される順番は (i) から (iv) となります。</p>

<p>画面と照らし合わせてみると、ユーザから見て手前側の View から onTouchEvent() が呼び出されていることを確認できるかと思います。</p>

<h2>タッチイベントを処理した場合の流れ</h2>

<p>タッチイベントは以上の流れで伝搬していきますが、いずれかのメソッドで true が返された場合、そこで連鎖がとまり、以降の処理は実行されなくなります。</p>

<p>例として、以下のように Button で onTouchEvent() を処理して true を返してみます。
``` java
public class TouchTestActivity implements OnTouchListener {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    // ...
    findViewById(R.id.button).setOnTouchListener(this);
}

@Override
protected void onTouch(View v, MotionEvent event) {
    int id = v.getId();
    switch(id) {
    case R.id.button:
        Log.d(TAG, "Touched!");
        return true;
    }
    return false;
}
</code></pre>

<p>}
```</p>

<p>この場合、 Button の onTouchEvent() でイベントの伝搬が停止するため、 FrameLayout3 の onTouchEvent() はコールされず、 FrameLayout2 は onDispatchTouchEvent() すら呼ばれません。
つまり、ユーザから見て「触ってイベントが発生した View より後ろにある View」には onTouchEvent() が一切発生しないことになります。</p>

<p><img src="/images/android_touch_event_flow_02.png" alt="TouchEvent Flow" /></p>

<p>OnTouchListener を登録したり onTouchEvent() を直接処理したりする以外にも、良くある例だと View#setOnClickListener() で OnClickListener を登録した場合なども、 onTouchEvent() で true が返るようになり、それ以降の View の onTouchEvent() はキャンセルされることになります。</p>

<p>子の OnClickListener などに影響されずにタッチイベントを処理したい場合は、子を呼びだすより前に呼ばれる onInterceptTouchEvent() で必要な処理を行うという方法があります。
例えば <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2.2_r1/android/widget/ScrollView.java#ScrollView.onInterceptTouchEvent%28android.view.MotionEvent%29">ScrollView</a> は子に影響されずにスクロール可能でなければならないため、 onInterceptTouchEvent() でスクロールの開始フラグを立てたりしています。</p>

<h2>onInterceptTouchEvent() で伝搬を止めた場合</h2>

<p>ViewGroup に実装されている onInterceptTouchEvent() で true を返すと、子供の View にイベントを伝搬しないようになります。</p>

<p>たとえば、以下のように onInterceptTouchEvent() で true を返すようにした CustomFrameLayout で FrameLayout3 を置き換えてみます。
``` java
public class CustomFrameLayout extends FrameLayout {</p>

<pre><code>// ...
@Override
public boolean onInterceptTouchEvent() {
    return true;
}
// ...
</code></pre>

<p>}
```</p>

<p>この場合、 FrameLayout3 が子供(Button)にイベントを伝搬しなくなるため、以下のようなイベントの発生順序になります。</p>

<p><img src="/images/android_touch_event_flow_03.png" alt="TouchEvent Flow" /></p>

<p>また <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2.2_r1/android/widget/ScrollView.java#ScrollView.onInterceptTouchEvent%28android.view.MotionEvent%29">ScrollView</a> を例にあげると、スクロール中は子供のタッチイベントを発生させないようにする必要があるため、 onInterceptTouchEvent() が活用されている様子を見る事ができます。(イベントのアクションが MotionEvent.ACTION_MOVE かつドラッグ中フラグが立っていたら子へ伝搬させないなど)</p>

<p>また、この onInterceptTouchEvent() を使って親側から子へのイベントの伝搬が止められることがある場合、子供側から止めないようにお願いする事ができます。
イベントの伝搬を親側から止めないようにする場合は、親の <a href="http://developer.android.com/reference/android/view/ViewParent.html#requestDisallowInterceptTouchEvent%28boolean%29">requestDisallowInterceptTouchEvent()</a> を呼びます。</p>

<p>```
public class TouchTestActivity {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    // ...
    findViewById(R.id.button).getParent().requestDisqllowInterceptTouchEvent(true);
}
</code></pre>

<p>}
```</p>

<p><img src="/images/android_touch_event_flow_04.png" alt="TouchEvent Flow" /></p>

<p>requestDisallowInterceptTouchEvent(true) で onInterceptTouchEvent() を抑制した場合、親の onInterceptTouchEvent() が呼ばれないことになるので、子にイベントを流すようにするだけでなく、副産物的に onInterceptTouchEvent() で行っている処理を無視させることができます。</p>

<p>たとえば、 requestDisallowInterceptTouchEvent() と加えて、子の onTouchEvent() で true を返すなどしてイベントの伝搬を子で止めてしまえば ScrollView のスクロールを無効化できたりします。
このあたりを組み合わせると、入れ子状の ScrollView を実現できたりします。</p>

<h2>次回予告？</h2>

<p>自力でイベントをルーティングする場合の話や、 Action の話なども書こうと思いましたが、思ったより長くなってしまったので、気が向いたらまた次回書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewGroup では onDraw() の代わりに dispatchDraw() が呼ばれる]]></title>
    <link href="http://blog.lciel.jp/blog/2013/11/27/viewgroup-dispatchdraw/"/>
    <updated>2013-11-27T20:18:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/11/27/viewgroup-dispatchdraw</id>
    <content type="html"><![CDATA[<p>FrameLayout で onDraw() のタイミングで処理をしたいが、どうも onDraw() が呼ばれないように見える。</p>

<p>確認したところ、 ViewGroup を継承したクラスは onDraw() の代わり dispatchDraw() が呼ばれるようだった。<br/>
(その名の通り子の View に対して draw() をコールしたりしなかったりするメソッド)</p>

<p>ViewGroup を継承したクラスに対して onDraw() のタイミングで実行したい処理は、 dispatchDraw() に書けば問題なさそう。
``` java
@Override
protected void dispatchDraw(Canvas canvas) {</p>

<pre><code>/*
    canvas に対して処理をしたりなんだり...
*/
super.dispatchDraw(canvas);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
