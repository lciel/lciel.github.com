<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Unmotivated]]></title>
  <link href="http://lciel.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://lciel.github.io/"/>
  <updated>2013-11-26T10:29:37+09:00</updated>
  <id>http://lciel.github.io/</id>
  <author>
    <name><![CDATA[lciel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 4.3 で ImageView#getImageMatrix() の挙動が変わっている]]></title>
    <link href="http://lciel.github.io/blog/2013/11/25/imageview-getimagematrix/"/>
    <updated>2013-11-25T11:19:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/25/imageview-getimagematrix</id>
    <content type="html"><![CDATA[<p>今まで ImageView#getImageMatrix() で取得した Matrix のインスタンスに対して、直接 post*() のメソッドを呼んだりして操作すれば表示に反映されていたが、どうやら 4.3 で挙動が変わったご様子。</p>

<p>結論から言うと、横着せずにちゃんと毎回 setImageMatrix() をしてやるか、はじめに setImageMatrix() してから getImageMatrix() を使うようにすれば想定通りに動作する。
``` java
ImageView imageView = findViewById(R.id.imageView);</p>

<p>float ratio = 2.0f;
Matrix matrix = imageView.getImageMatrix();
matrix.postScale(ratio, ratio);</p>

<p>matrix.setImageMatrix(matrix);
<code>
</code> java
ImageView imageView = findViewById(R.id.imageView);</p>

<p>Matrix matrix = new Matrix();
imageView.setImageMatrix();</p>

<p>float ratio = 2.0f;
matrix = imageView.getImageMatrix();
matrix.postScale(ratio, ratio);
```</p>

<h3>どう変わってるのか確認</h3>

<p>4.2 以前では mMatrix (initImageView()で初期化されてる)がそのまま返っているのに対して、 4.3 以降では mDrawMatrix が返るようになっている。
(mDrawMatrix は configureBounds() でセットされている)</p>

<p>mDrawMatrix がセットされていない状態だと、その場で Matrix のインスタンスが作られているため、このインスタンスに対して直接操作を行っても反映されないというわけでした。</p>

<p>``` java 4.2_r1 android.widget.ImageView#getImageMatrix() <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29</a>
public Matrix getImageMatrix() {</p>

<pre><code>return mMatrix;
</code></pre>

<p>}
<code>
</code> java 4.3_r1 android.widget.ImageView#getImageMatrix() <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.3_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.3_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29</a>
public Matrix getImageMatrix() {</p>

<pre><code>if (mDrawMatrix == null) {
    return new Matrix(Matrix.IDENTITY_MATRIX);
}
return mDrawMatrix;
</code></pre>

<p>}
```</p>

<p>Android はマイナーバージョンアップでも、結構こういう細かい挙動変更が入ってくるので、以前動いていたものが突然動かなくなることが良くあるのだけれど、Android のコードを直接見に行けば答えが書いてあるので安心感がありますね。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ListView で onItemClick() と onItemLongClick() を両立]]></title>
    <link href="http://lciel.github.io/blog/2013/11/22/onitemclick-vs-onitemlongclick/"/>
    <updated>2013-11-22T18:50:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/22/onitemclick-vs-onitemlongclick</id>
    <content type="html"><![CDATA[<p>ListView で onItemClick() と onItemLongClick() を同時に仕掛けた際に、指を離すタイミングによっては onItemLongClick() に続けて onItemClick() が呼ばれてしまう。</p>

<p>一般的な Touch Event の例に漏れず、 onItemLongClick() で true を返しておけば、その後のイベントはキャンセルされる。
``` java
@Override
public void onItemClick(AdapterView&lt;?> parent, View view, int position, long id) {</p>

<pre><code>/*
    なんやかんや
*/
</code></pre>

<p>}</p>

<p>@Override
public boolean onItemLongClick(AdapterView&lt;?> parent, View view, int position, long id) {</p>

<pre><code>/*
    なんやかんや
*/
return true;    // これで onItemLongClick() のあとに onItemClick() が呼ばれなくなる
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewFlipper の InAnimation を1つ目には適用しない]]></title>
    <link href="http://lciel.github.io/blog/2013/11/21/disable-in-animation-of-viewflipper/"/>
    <updated>2013-11-21T20:58:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/21/disable-in-animation-of-viewflipper</id>
    <content type="html"><![CDATA[<p>ViewFlipper に InAnimation を設定した状態で startFlipping() をコールした際に、1つ目の View にも InAnimation が適用されてしまうのを回避したい。</p>

<p>AutoStart を指定せずに明示的に startFlipping() をコールした後に setInAnimation() してやれば OK
``` java
ViewFlipper viewFlipper = (ViewFlipper) findViewById(R.id.viewFlipper);</p>

<p>// viewFlipper.setAutoStart(true);
viewFlipper.startFlipping();
viewFlipper.setInAnimation(this, R.anim.fadein);
viewFlipper.setOutAnimation(this, R.anim.fadeout);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 端末のシェアを視覚的に見る]]></title>
    <link href="http://lciel.github.io/blog/2013/11/21/android-fragmentation-visualized/"/>
    <updated>2013-11-21T20:46:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/21/android-fragmentation-visualized</id>
    <content type="html"><![CDATA[<p>OpenSignal が公開してくれている、 Android 端末毎のシェアを視覚的に表示してくれるサービス。</p>

<ul>
<li><a href="http://opensignal.com/reports/fragmentation-2013/">Android Fragmentation Visualized</a></li>
</ul>


<p>こうみると SAMSUNG 一強だな。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 2.x で表示される ScrollView の端のフェード(Fading Edge)を消す]]></title>
    <link href="http://lciel.github.io/blog/2013/11/21/remove-fading-edge/"/>
    <updated>2013-11-21T20:30:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/21/remove-fading-edge</id>
    <content type="html"><![CDATA[<p>Android 2.x 系ではスクロール可能な方向に Fading Edge が表示されるが、それを消したい。</p>

<h3>fadingEdge を指定する方法</h3>

<ul>
<li>xml で指定
<code>xml
&lt;ScrollView
  ...
  android:fadingEdge="none"
  ...
  /&gt;
</code></li>
<li>ICS 以上では android:requiresFadingEdge が代わりに適用される</li>
</ul>


<h3>fadingEdgeLength を 0dp に指定する方法</h3>

<ul>
<li>xml
<code>xml
&lt;ScrollView
  ...
  android:fadingEdgeLength="0dp"
  ...
  /&gt;
</code></li>
<li>直接コードで指定する場合はこう
<code>java
ListView listView = findViewById(R.id.listView);
listView.setFadingEdgeLength(0);
</code></li>
</ul>

]]></content>
  </entry>
  
</feed>
