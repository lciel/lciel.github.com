<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Unmotivated]]></title>
  <link href="http://blog.lciel.jp/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://blog.lciel.jp/"/>
  <updated>2013-12-06T20:17:25+09:00</updated>
  <id>http://blog.lciel.jp/</id>
  <author>
    <name><![CDATA[lciel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ファイル名に特定の記号が使用できる場合とできない場合がある]]></title>
    <link href="http://blog.lciel.jp/blog/2013/12/06/android-sdcard-vfat/"/>
    <updated>2013-12-06T21:11:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/12/06/android-sdcard-vfat</id>
    <content type="html"><![CDATA[<p>Android のバージョンは同じなのに、端末によってファイルの移動(renameTo())に失敗してしまうことがあって悩まされたが、オチは移動先のファイル名にクエスチョンマーク(&ldquo;?&rdquo;)が含まれていたことが原因だった。</p>

<p>クエスチョンマークが入ってしまっていたこと自体がバグだったのだけれど、そもそも何で端末によってこのようなことが起きるのかを軽く追ってみた。</p>

<h3>原因はファイルシステム(っぽい)</h3>

<p>成功する端末では内部ストレージに書き込みを行っており、失敗する端末では外部ストレージに書き込みを行っていた。</p>

<p>ファイルシステムを見てみると、内部ストレージは FUSE でマウントされているのに対し、外部ストレージは VFAT でマウントされていた。</p>

<p>``` text mount の状態</p>

<h1>内部ストレージとして認識されているディレクトリ</h1>

<p>/dev/fuse /storage/sdcard0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</p>

<h1>外部ストレージとして認識されているディレクトリ</h1>

<p>/dev/block/vold/179:33 /storage/sdcard0/external_sd vfat rw,dirsync,nosuid,nodev,noexec,relatime,uid=1000,gid=1015,fmask=0602,dmask=0602,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0
```</p>

<p>正式な出典が見つからなかったけれど、 VFAT ではファイル名に以下の文字の使用を禁止しているようなので、恐らくこれが原因っぽい。<br/>
試しにその他の記号を含めたファイル名を作成してみたところ、全て失敗した。</p>

<p><code>text
\ : * ? &lt; &gt; | / ;
</code></p>

<p>参考 : (ファイル名とフォルダ名で使用できない文字)[<a href="http://www2s.biglobe.ne.jp/~system/doc/winfile2.htm">http://www2s.biglobe.ne.jp/~system/doc/winfile2.htm</a>]</p>

<p>というわけで、環境によって(サンプル数は少ないが、恐らく外部SDカードでは)一部の記号がファイル名に使えなくなることがある、ということが分かった。</p>

<h3>メモ</h3>

<p>Android のファイルシステム周りについては全く調べられていないが、いくつか気になることがあったのでメモ。</p>

<ul>
<li>エミュレータでは FUSE ではなく YAFFS2 でマウントされていた(どこのレイヤーで変わってるのか不明)</li>
<li><a href="http://source.android.com/devices/tech/storage/">ここ</a>を見ると、 Android 4.4 からは外部ストレージも FUSE 経由でマウントするようになるっぽい？が、4.4 のエミュレータが起動せず、実機も外部メモリがマウントできない端末しかなく確認できず (raw storage をラップしているとあるので、今回の件は実体の方でこけそうな感じがしますが)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ListView#setEmptyView() について]]></title>
    <link href="http://blog.lciel.jp/blog/2013/12/04/listview-setemptyview/"/>
    <updated>2013-12-04T21:10:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/12/04/listview-setemptyview</id>
    <content type="html"><![CDATA[<p>ListView の要素が無い場合に表示する View を指定できる setEmptyView() だが、その名前から想像できるのとは少し違う動きをする。</p>

<ul>
<li>違 : 「要素が無い場合に ListView の子供として表示させる View が設定できる」</li>
<li>正 : 「要素が無い場合に ListView の代わりに表示する View が設定できる」</li>
</ul>


<p>実際の動作は setEmptyView() で指定した View と ListView の Visibility を View.GONE と View.VISIBLE で入れ替えるだけとなっている。</p>

<p>そのため、 inflate() しただけでどこにも addView() していない View などを setEmptyView() で指定しても表示されないし、 ListView の子として表示される Header や Footer も表示されないこととなる。</p>

<p>通常は ListView と同階層に兄弟 View として xml に定義しておくのがよさそう。<br/>
EmptyView として設定する View の Visibility は特に指定しなくても ListView 側でやってくれるので問題ないです。
```xml
&lt;ListView</p>

<pre><code>android:id="@+id/listView"
... /&gt;
</code></pre>

<p>&lt;View</p>

<pre><code>android:id="@+id/emptyView"
... /&gt;
</code></pre>

<p><code>
</code>java
ListView listView = (ListView) findViewById(R.id.listView);
listView.setEmptyView(findViewById(R.id.emptyView));
```</p>

<p>以下は実装箇所の確認。
```java android.widget.AdapterView(1.6_r2)
private void More &hellip;updateEmptyStatus(boolean empty) {</p>

<pre><code>if (isInFilterMode()) {
    empty = false;
}

if (empty) {
    // EmptyView が設定されていた場合は自身を消して、 EmptyView を表示させている
    if (mEmptyView != null) {
        mEmptyView.setVisibility(View.VISIBLE);
        setVisibility(View.GONE);
    } else {
        // If the caller just removed our empty view, make sure the list view is visible
        setVisibility(View.VISIBLE);
    }
    // ...

} else {
    // ...
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android のタッチイベントを理解する(その1)]]></title>
    <link href="http://blog.lciel.jp/blog/2013/12/03/android-touch-event/"/>
    <updated>2013-12-03T20:31:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/12/03/android-touch-event</id>
    <content type="html"><![CDATA[<p>タッチイベントがうまく流れてこなくて困ったり、自力でイベントをルーティングしたりするときに困ったりと、ちょこちょことタッチイベントについて勉強したのでまとめておきます。<br/>
主にタッチイベントがどう流れてどう止まるかなどについて調べています。</p>

<p>イベントの流れを理解するには以下の資料がかなり参考になりました。</p>

<ul>
<li><a href="http://devsbuild.it/files/PRE_andevcon_mastering-the-android-touch-system.pdf">Mastering the Android Touch System (PDF)</a></li>
</ul>


<p>毎度のことながら、間違いがありましたらご指摘頂ければ幸いです。</p>

<!-- more -->


<h2>タッチイベントを処理する主要なメソッド</h2>

<p>実際の流れを理解する前に、主要なメソッドを三つ紹介しておきます。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> <strong>メソッド名</strong> </th>
<th align="left"> <strong>概要</strong> </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> onTouchEvent() (<a href="http://developer.android.com/reference/android/view/View.html#onTouchEvent(android.view.MotionEvent">View</a>) </td>
<td align="left"> タッチイベントに対して何かを処理するメソッド。setOnTouchListener() で登録した listener はこのタイミングで呼び出される。</td>
</tr>
<tr>
<td></td>
<td align="left"> onInterceptTouchEvent() (<a href="http://developer.android.com/reference/android/view/ViewGroup.html#onInterceptTouchEvent(android.view.MotionEvent">ViewGroup</a>) </td>
<td align="left"> タッチイベントが子供へと伝搬することを阻止できるメソッド。</td>
</tr>
<tr>
<td></td>
<td align="left"> dispatchTouchEvent() (<a href="http://developer.android.com/reference/android/app/Activity.html#dispatchTouchEvent(android.view.MotionEvent">Activity</a>, <a href="http://developer.android.com/reference/android/view/View.html#dispatchTouchEvent(android.view.MotionEvent">View</a>, <a href="http://developer.android.com/reference/android/view/ViewGroup.html#dispatchTouchEvent(android.view.MotionEvent">ViewGroup</a>) </td>
<td align="left"> タッチイベントを受け取り、子に伝搬させるかどうか、自分が処理するかどうかなどを管理する。onInterceptTouchEvent() や onTouchEvent() を呼ぶ人。</td>
</tr>
</tbody>
</table>


<p>　</p>

<h2>基本的なタッチイベントの流れ</h2>

<p>タッチイベントは Activity を経由して PhoneWindow 直下の DecorView から伝搬が始まり、親の View からその子 View へと dispatchTouchEvent() なるメソッドを通じて伝搬していきます。</p>

<p>dispatchTouchEvent() は 自身が ViewGroup だった場合、まず自身の onInterceptTouchEvent() を呼び出します。
onInterceptTouchEvent() では子にイベントを渡すかどうかなどを判断します(後で詳しく説明します)。</p>

<p>次に、子の dispatchTouchEvent() を呼び出してイベントを渡していきます。
このとき、親が子の dispatchTouchEvent() を呼び出す順番は、一番新しく追加した子から古い子へと逆順に渡していきます。</p>

<p>そして、最後に一般的にタッチイベントを処理するメソッドである onTouchEvent() が dispatchTouchEvent() によって呼ばれます。
この onTouchEvent() は、子から親へと逆順(ユーザから見ると手前に表示されている順)に流れていくようになっています。</p>

<p>文章だけだと分かりづらいので、たとえば以下のような構成の View の場合を考えてみます。</p>

<p><img src="/images/android_touch_event_sample_view.png" alt="Sample View" />
<code>`` text
FrameLayout1(白)
|-- FrameLayout2(赤)
</code>&mdash; FrameLayout3(緑)</p>

<pre><code>`- Button
</code></pre>

<p>```</p>

<p>この構成の場合、いずれの View もタッチイベントを処理しない、最もシンプルなイベントの流れは以下のようになります。</p>

<p><img src="/images/android_touch_event_flow_01.png" alt="TouchEvent Flow" /></p>

<p>(1) から (13) の順番で処理が流れ、 onInterceptTouchEvent() が呼び出される順番は (I) から (III) となり、肝心の onTouchEvent() が呼び出される順番は (i) から (iv) となります。</p>

<p>画面と照らし合わせてみると、ユーザから見て手前側の View から onTouchEvent() が呼び出されていることを確認できるかと思います。</p>

<h2>タッチイベントを処理した場合の流れ</h2>

<p>タッチイベントは以上の流れで伝搬していきますが、いずれかのメソッドで true が返された場合、そこで連鎖がとまり、以降の処理は実行されなくなります。</p>

<p>例として、以下のように Button で onTouchEvent() を処理して true を返してみます。
``` java
public class TouchTestActivity implements OnTouchListener {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    // ...
    findViewById(R.id.button).setOnTouchListener(this);
}

@Override
protected void onTouch(View v, MotionEvent event) {
    int id = v.getId();
    switch(id) {
    case R.id.button:
        Log.d(TAG, "Touched!");
        return true;
    }
    return false;
}
</code></pre>

<p>}
```</p>

<p>この場合、 Button の onTouchEvent() でイベントの伝搬が停止するため、 FrameLayout3 の onTouchEvent() はコールされず、 FrameLayout2 は onDispatchTouchEvent() すら呼ばれません。
つまり、ユーザから見て「触ってイベントが発生した View より後ろにある View」には onTouchEvent() が一切発生しないことになります。</p>

<p><img src="/images/android_touch_event_flow_02.png" alt="TouchEvent Flow" /></p>

<p>OnTouchListener を登録したり onTouchEvent() を直接処理したりする以外にも、良くある例だと View#setOnClickListener() で OnClickListener を登録した場合なども、 onTouchEvent() で true が返るようになり、それ以降の View の onTouchEvent() はキャンセルされることになります。</p>

<p>子の OnClickListener などに影響されずにタッチイベントを処理したい場合は、子を呼びだすより前に呼ばれる onInterceptTouchEvent() で必要な処理を行うという方法があります。
例えば <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2.2_r1/android/widget/ScrollView.java#ScrollView.onInterceptTouchEvent%28android.view.MotionEvent%29">ScrollView</a> は子に影響されずにスクロール可能でなければならないため、 onInterceptTouchEvent() でスクロールの開始フラグを立てたりしています。</p>

<h2>onInterceptTouchEvent() で伝搬を止めた場合</h2>

<p>ViewGroup に実装されている onInterceptTouchEvent() で true を返すと、子供の View にイベントを伝搬しないようになります。</p>

<p>たとえば、以下のように onInterceptTouchEvent() で true を返すようにした CustomFrameLayout で FrameLayout3 を置き換えてみます。
``` java
public class CustomFrameLayout extends FrameLayout {</p>

<pre><code>// ...
@Override
public boolean onInterceptTouchEvent() {
    return true;
}
// ...
</code></pre>

<p>}
```</p>

<p>この場合、 FrameLayout3 が子供(Button)にイベントを伝搬しなくなるため、以下のようなイベントの発生順序になります。</p>

<p><img src="/images/android_touch_event_flow_03.png" alt="TouchEvent Flow" /></p>

<p>また <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2.2_r1/android/widget/ScrollView.java#ScrollView.onInterceptTouchEvent%28android.view.MotionEvent%29">ScrollView</a> を例にあげると、スクロール中は子供のタッチイベントを発生させないようにする必要があるため、 onInterceptTouchEvent() が活用されている様子を見る事ができます。(イベントのアクションが MotionEvent.ACTION_MOVE かつドラッグ中フラグが立っていたら子へ伝搬させないなど)</p>

<p>また、この onInterceptTouchEvent() を使って親側から子へのイベントの伝搬が止められることがある場合、子供側から止めないようにお願いする事ができます。
イベントの伝搬を親側から止めないようにする場合は、親の <a href="http://developer.android.com/reference/android/view/ViewParent.html#requestDisallowInterceptTouchEvent%28boolean%29">requestDisallowInterceptTouchEvent()</a> を呼びます。</p>

<p>```
public class TouchTestActivity {</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    // ...
    findViewById(R.id.button).getParent().requestDisqllowInterceptTouchEvent(true);
}
</code></pre>

<p>}
```</p>

<p><img src="/images/android_touch_event_flow_04.png" alt="TouchEvent Flow" /></p>

<p>requestDisallowInterceptTouchEvent(true) で onInterceptTouchEvent() を抑制した場合、親の onInterceptTouchEvent() が呼ばれないことになるので、子にイベントを流すようにするだけでなく、副産物的に onInterceptTouchEvent() で行っている処理を無視させることができます。</p>

<p>たとえば、 requestDisallowInterceptTouchEvent() と加えて、子の onTouchEvent() で true を返すなどしてイベントの伝搬を子で止めてしまえば ScrollView のスクロールを無効化できたりします。
このあたりを組み合わせると、入れ子状の ScrollView を実現できたりします。</p>

<h2>次回予告？</h2>

<p>自力でイベントをルーティングする場合の話や、 Action の話なども書こうと思いましたが、思ったより長くなってしまったので、気が向いたらまた次回書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewGroup では onDraw() の代わりに dispatchDraw() が呼ばれる]]></title>
    <link href="http://blog.lciel.jp/blog/2013/11/27/viewgroup-dispatchdraw/"/>
    <updated>2013-11-27T20:18:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/11/27/viewgroup-dispatchdraw</id>
    <content type="html"><![CDATA[<p>FrameLayout で onDraw() のタイミングで処理をしたいが、どうも onDraw() が呼ばれないように見える。</p>

<p>確認したところ、 ViewGroup を継承したクラスは onDraw() の代わり dispatchDraw() が呼ばれるようだった。<br/>
(その名の通り子の View に対して draw() をコールしたりしなかったりするメソッド)</p>

<p>ViewGroup を継承したクラスに対して onDraw() のタイミングで実行したい処理は、 dispatchDraw() に書けば問題なさそう。
``` java
@Override
protected void dispatchDraw(Canvas canvas) {</p>

<pre><code>/*
    canvas に対して処理をしたりなんだり...
*/
super.dispatchDraw(canvas);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 4.3 で ImageView#getImageMatrix() の挙動が変わっている]]></title>
    <link href="http://blog.lciel.jp/blog/2013/11/25/imageview-getimagematrix/"/>
    <updated>2013-11-25T11:19:00+09:00</updated>
    <id>http://blog.lciel.jp/blog/2013/11/25/imageview-getimagematrix</id>
    <content type="html"><![CDATA[<p>今まで ImageView#getImageMatrix() で取得した Matrix のインスタンスに対して、直接 post*() のメソッドを呼んだりして操作すれば表示に反映されていたが、どうやら 4.3 で挙動が変わったご様子。</p>

<p>結論から言うと、横着せずにちゃんと毎回 setImageMatrix() をしてやるか、はじめに setImageMatrix() してから getImageMatrix() を使うようにすれば想定通りに動作する。
``` java
ImageView imageView = findViewById(R.id.imageView);</p>

<p>float ratio = 2.0f;
Matrix matrix = imageView.getImageMatrix();
matrix.postScale(ratio, ratio);</p>

<p>matrix.setImageMatrix(matrix);
<code>
</code> java
ImageView imageView = findViewById(R.id.imageView);</p>

<p>Matrix matrix = new Matrix();
imageView.setImageMatrix();</p>

<p>float ratio = 2.0f;
matrix = imageView.getImageMatrix();
matrix.postScale(ratio, ratio);
```</p>

<h3>どう変わってるのか確認</h3>

<p>4.2 以前では mMatrix (initImageView()で初期化されてる)がそのまま返っているのに対して、 4.3 以降では mDrawMatrix が返るようになっている。
(mDrawMatrix は configureBounds() でセットされている)</p>

<p>mDrawMatrix がセットされていない状態だと、その場で Matrix のインスタンスが作られているため、このインスタンスに対して直接操作を行っても反映されないというわけでした。</p>

<p>``` java 4.2_r1 android.widget.ImageView#getImageMatrix() <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.2_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29</a>
public Matrix getImageMatrix() {</p>

<pre><code>return mMatrix;
</code></pre>

<p>}
<code>
</code> java 4.3_r1 android.widget.ImageView#getImageMatrix() <a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.3_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.3_r1/android/widget/ImageView.java#ImageView.getImageMatrix%28%29</a>
public Matrix getImageMatrix() {</p>

<pre><code>if (mDrawMatrix == null) {
    return new Matrix(Matrix.IDENTITY_MATRIX);
}
return mDrawMatrix;
</code></pre>

<p>}
```</p>

<p>Android はマイナーバージョンアップでも、結構こういう細かい挙動変更が入ってくるので、以前動いていたものが突然動かなくなることが良くあるのだけれど、Android のコードを直接見に行けば答えが書いてあるので安心感がありますね。</p>
]]></content>
  </entry>
  
</feed>
