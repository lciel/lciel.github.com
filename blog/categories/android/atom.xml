<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Unmotivated]]></title>
  <link href="http://lciel.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://lciel.github.io/"/>
  <updated>2013-11-22T18:56:46+09:00</updated>
  <id>http://lciel.github.io/</id>
  <author>
    <name><![CDATA[lciel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ListView で onItemClick() と onItemLongClick() を両立]]></title>
    <link href="http://lciel.github.io/blog/2013/11/22/onitemclick-vs-onitemlongclick/"/>
    <updated>2013-11-22T18:50:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/22/onitemclick-vs-onitemlongclick</id>
    <content type="html"><![CDATA[<p>ListView で onItemClick() と onItemLongClick() を同時に仕掛けた際に、指を離すタイミングによっては onItemLongClick() に続けて onItemClick() が呼ばれてしまう。</p>

<p>Touch Event の例に漏れず、 onItemLongClick() で true を返しておけば、その後のイベントはキャンセルされる。
``` java
@Override
public void onItemClick(AdapterView&lt;?> parent, View view, int position, long id) {</p>

<pre><code>/*
    なんやかんや
*/
</code></pre>

<p>}</p>

<p>@Override
public boolean onItemLongClick(AdapterView&lt;?> parent, View view, int position, long id) {</p>

<pre><code>/*
    なんやかんや
*/
return true;    // これで onItemLongClick() のあとに onItemClick() が呼ばれなくなる
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ViewFlipper の InAnimation を1つ目には適用しない]]></title>
    <link href="http://lciel.github.io/blog/2013/11/21/disable-in-animation-of-viewflipper/"/>
    <updated>2013-11-21T20:58:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/21/disable-in-animation-of-viewflipper</id>
    <content type="html"><![CDATA[<p>ViewFlipper に InAnimation を設定した状態で startFlipping() をコールした際に、1つ目の View にも InAnimation が適用されてしまうのを回避したい。</p>

<p>AutoStart を指定せずに明示的に startFlipping() をコールした後に setInAnimation() してやれば OK
``` java
ViewFlipper viewFlipper = (ViewFlipper) findViewById(R.id.viewFlipper);</p>

<p>// viewFlipper.setAutoStart(true);
viewFlipper.startFlipping();
viewFlipper.setInAnimation(this, R.anim.fadein);
viewFlipper.setOutAnimation(this, R.anim.fadeout);
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 端末のシェアを視覚的に見る]]></title>
    <link href="http://lciel.github.io/blog/2013/11/21/android-fragmentation-visualized/"/>
    <updated>2013-11-21T20:46:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/21/android-fragmentation-visualized</id>
    <content type="html"><![CDATA[<p>OpenSignal が公開してくれている、 Android 端末毎のシェアを視覚的に表示してくれるサービス。</p>

<ul>
<li><a href="http://opensignal.com/reports/fragmentation-2013/">Android Fragmentation Visualized</a></li>
</ul>


<p>こうみると SAMSUNG 一強だな。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 2.x で表示される ScrollView の端のフェード(Fading Edge)を消す]]></title>
    <link href="http://lciel.github.io/blog/2013/11/21/remove-fading-edge/"/>
    <updated>2013-11-21T20:30:00+09:00</updated>
    <id>http://lciel.github.io/blog/2013/11/21/remove-fading-edge</id>
    <content type="html"><![CDATA[<p>Android 2.x 系ではスクロール可能な方向に Fading Edge が表示されるが、それを消したい。</p>

<h3>fadingEdge を指定する方法</h3>

<ul>
<li>xml で指定
<code>xml
&lt;ScrollView
  ...
  android:fadingEdge="none"
  ...
  /&gt;
</code></li>
<li>ICS 以上では android:requiresFadingEdge が代わりに適用される</li>
</ul>


<h3>fadingEdgeLength を 0dp に指定する方法</h3>

<ul>
<li>xml
<code>xml
&lt;ScrollView
  ...
  android:fadingEdgeLength="0dp"
  ...
  /&gt;
</code></li>
<li>直接コードで指定する場合はこう
<code>java
ListView listView = findViewById(R.id.listView);
listView.setFadingEdgeLength(0);
</code></li>
</ul>

]]></content>
  </entry>
  
</feed>
